package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.78

import (
	"context"
	"fmt"
	"gateway/internal/services"
	"strings"
)

// Login is the resolver for the login mutation.
func (r *mutationResolver) Login(ctx context.Context, email string, password string) (*AuthResponse, error) {
	authClient := services.AuthServiceClient{BaseURL: "http://localhost:8081"}
	authResp, err := authClient.Login(email, password)
	if err != nil {
		return nil, err
	}
	userResp, err := authClient.GetCurrentUser(authResp.Token)
	if err != nil {
		return nil, err
	}
	user := &User{
		ID:    userResp.ID,
		Email: userResp.Email,
		Role:  userResp.Role,
	}
	return &AuthResponse{
		Token: authResp.Token,
		User:  user,
	}, nil
}

// CreateUser is the resolver for the createUser mutation.
func (r *mutationResolver) CreateUser(ctx context.Context, input CreateUserInput) (*User, error) {
	authHeader, _ := ctx.Value(authTokenKey).(string)
	authClient := services.AuthServiceClient{BaseURL: "http://localhost:8081"}

	// Convert our GraphQL input into the structure the REST API expects.
	payload := map[string]interface{}{
		"email":    input.Email,
		"password": input.Password,
		"role":     input.Role,
	}
	if input.StudentProfile != nil {
		payload["studentProfile"] = input.StudentProfile
	}
	if input.InstructorProfile != nil {
		payload["instructorProfile"] = input.InstructorProfile
	}

	userResp, err := authClient.CreateUser(authHeader, payload)
	if err != nil {
		return nil, err
	}

	return &User{
		ID:       userResp.ID,
		Email:    userResp.Email,
		Role:     userResp.Role,
		FullName: &userResp.FullName,
	}, nil
}

// CreateCourse is the resolver for the createCourse mutation.
func (r *mutationResolver) CreateCourse(ctx context.Context, input CreateCourseInput) (*Course, error) {
	authHeader, _ := ctx.Value(authTokenKey).(string)
	erpClient := services.ERPServiceClient{BaseURL: "http://localhost:8082"}

	courseResp, err := erpClient.CreateCourse(authHeader, input)
	if err != nil {
		return nil, err
	}

	return &Course{
		ID:         courseResp.ID,
		CourseCode: courseResp.CourseCode,
		Name:       courseResp.Name,
		Credits:    courseResp.Credits,
	}, nil
}

// RegisterForCourse is the resolver for the registerForCourse mutation.
func (r *mutationResolver) RegisterForCourse(ctx context.Context, courseID string, semester string) (*Registration, error) {
	authHeader, _ := ctx.Value(authTokenKey).(string)
	erpClient := services.ERPServiceClient{BaseURL: "http://localhost:8082"}
	regResp, err := erpClient.RegisterForCourse(authHeader, courseID, semester)
	if err != nil {
		return nil, err
	}
	return &Registration{
		CourseID: regResp.CourseID,
		Semester: regResp.Semester,
	}, nil
}

// SyncClassroom is the resolver for the syncClassroom field.
func (r *mutationResolver) SyncClassroom(ctx context.Context, courseID string, semester string) (*Classroom, error) {
	// 1. Get token from context
	authHeader, _ := ctx.Value(authTokenKey).(string)

	// 2. Initialize clients for all 3 services
	erpClient := services.ERPServiceClient{BaseURL: "http://localhost:8082"}
	authClient := services.AuthServiceClient{BaseURL: "http://localhost:8081"}
	// This is your new Python service
	classroomClient := services.ClassroomServiceClient{BaseURL: "http://localhost:8083"}

	// 3. Get the Course details (for name and instructorId)
	// This method now exists
	courseResp, err := erpClient.GetCourseByID(authHeader, courseId)
	if err != nil {
		return nil, fmt.Errorf("failed to get course from ERP: %w", err)
	}

	// 4. Get the student roster from ERP service
	// This endpoint already exists!
	roster, err := erpClient.GetCourseRoster(authHeader, courseId, semester)
	if err != nil {
		return nil, fmt.Errorf("failed to get roster from ERP: %w", err)
	}

	var studentIDs []string
	for _, reg := range roster {
		studentIDs = append(studentIDs, reg.UserID)
	}

	// 5. Call the new classroom service's /sync endpoint
	syncPayload := map[string]interface{}{
		"course_id":     courseId,
		"instructor_id": courseResp.InstructorID,
		"semester":      semester,
		"name":          fmt.Sprintf("%s (%s)", courseResp.Name, semester),
		"student_ids":   studentIDs,
	}

	// This method now exists
	classroomResp, err := classroomClient.SyncClassroom(authHeader, syncPayload)
	if err != nil {
		return nil, fmt.Errorf("failed to sync classroom: %w", err)
	}

	// 6. Get instructor details
	instructor, _ := authClient.GetUserByID(authHeader, courseResp.InstructorID)

	// 7. FIX: Remove "graph." prefix
	return &Classroom{
		ID:       classroomResp.ID,
		CourseId: classroomResp.CourseID,
		Name:     classroomResp.Name,
		Semester: classroomResp.Semester,
		Instructor: &User{ // <-- FIX: Removed "graph."
			ID:       instructor.ID,
			Email:    instructor.Email,
			Role:     instructor.Role,
			FullName: &instructor.FullName,
		},
	}, nil
}

// PostModule is the resolver for the postModule field.
func (r *mutationResolver) PostModule(ctx context.Context, classroomID string, title string, content string) (*Classroom, error) {
	panic(fmt.Errorf("not implemented: PostModule - postModule"))
}

// PostAnnouncement is the resolver for the postAnnouncement field.
func (r *mutationResolver) PostAnnouncement(ctx context.Context, classroomID string, content string) (*Classroom, error) {
	panic(fmt.Errorf("not implemented: PostAnnouncement - postAnnouncement"))
}

// CreateAssignment is the resolver for the createAssignment field.
func (r *mutationResolver) CreateAssignment(ctx context.Context, input CreateAssignmentInput) (*Assignment, error) {
	panic(fmt.Errorf("not implemented: CreateAssignment - createAssignment"))
}

// SubmitWork is the resolver for the submitWork field.
func (r *mutationResolver) SubmitWork(ctx context.Context, input SubmitWorkInput) (*Submission, error) {
	panic(fmt.Errorf("not implemented: SubmitWork - submitWork"))
}

// GradeSubmission is the resolver for the gradeSubmission field.
func (r *mutationResolver) GradeSubmission(ctx context.Context, input GradeSubmissionInput) (*Submission, error) {
	panic(fmt.Errorf("not implemented: GradeSubmission - gradeSubmission"))
}

// Me is the resolver for the me query.
func (r *queryResolver) Me(ctx context.Context) (*User, error) {
	authHeader, _ := ctx.Value(authTokenKey).(string)
	rawToken := ""
	parts := strings.Split(authHeader, " ")
	if len(parts) == 2 {
		rawToken = parts[1]
	}
	authClient := services.AuthServiceClient{BaseURL: "http://localhost:8081"}
	userResp, err := authClient.GetCurrentUser(rawToken)
	if err != nil {
		return nil, err
	}
	return &User{
		ID:    userResp.ID,
		Email: userResp.Email,
		Role:  userResp.Role,
	}, nil
}

// Courses is the resolver for the courses query.
func (r *queryResolver) Courses(ctx context.Context) ([]*Course, error) {
	authHeader, _ := ctx.Value(authTokenKey).(string)
	authClient := services.AuthServiceClient{BaseURL: "http://localhost:8081"}
	erpClient := services.ERPServiceClient{BaseURL: "http://localhost:8082"}
	coursesResp, err := erpClient.ListCourses(authHeader)
	if err != nil {
		return nil, err
	}
	var gqlCourses []*Course
	for _, c := range coursesResp {
		instructor, err := authClient.GetUserByID(authHeader, c.InstructorID)
		var gqlInstructor *User
		if err == nil {
			gqlInstructor = &User{
				ID:       instructor.ID,
				Email:    instructor.Email,
				Role:     instructor.Role,
				FullName: &instructor.FullName,
			}
		}
		desc := c.Description
		gqlCourses = append(gqlCourses, &Course{
			ID:          c.ID,
			CourseCode:  c.CourseCode,
			Name:        c.Name,
			Description: &desc,
			Credits:     c.Credits,
			Instructor:  gqlInstructor,
		})
	}
	return gqlCourses, nil
}

// MyRegistrations is the resolver for the myRegistrations query.
func (r *queryResolver) MyRegistrations(ctx context.Context) ([]*Registration, error) {
	authHeader, _ := ctx.Value(authTokenKey).(string)
	erpClient := services.ERPServiceClient{BaseURL: "http://localhost:8082"}

	regResp, err := erpClient.ListMyRegistrations(authHeader)
	if err != nil {
		return nil, err
	}

	// Convert the service response into the GraphQL model.
	var gqlRegistrations []*Registration
	for _, r := range regResp {
		gqlRegistrations = append(gqlRegistrations, &Registration{
			CourseID: r.CourseID,
			Semester: r.Semester,
			// The 'course' field will be resolved by a separate field resolver if needed.
		})
	}

	return gqlRegistrations, nil
}

// MyClassrooms is the resolver for the myClassrooms field.
func (r *queryResolver) MyClassrooms(ctx context.Context) ([]*Classroom, error) {
	panic(fmt.Errorf("not implemented: MyClassrooms - myClassrooms"))
}

// GetClassroomDetails is the resolver for the getClassroomDetails field.
func (r *queryResolver) GetClassroomDetails(ctx context.Context, classroomID string) (*Classroom, error) {
	panic(fmt.Errorf("not implemented: GetClassroomDetails - getClassroomDetails"))
}

// GetAssignmentSubmissions is the resolver for the getAssignmentSubmissions field.
func (r *queryResolver) GetAssignmentSubmissions(ctx context.Context, assignmentID string) ([]*Submission, error) {
	panic(fmt.Errorf("not implemented: GetAssignmentSubmissions - getAssignmentSubmissions"))
}

// GetMySubmission is the resolver for the getMySubmission field.
func (r *queryResolver) GetMySubmission(ctx context.Context, assignmentID string) (*Submission, error) {
	panic(fmt.Errorf("not implemented: GetMySubmission - getMySubmission"))
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
