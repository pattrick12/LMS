package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.78

import (
	"context"
	"gateway/internal/services"
	"strings"
)

// Login is the resolver for the login mutation.
func (r *mutationResolver) Login(ctx context.Context, email string, password string) (*AuthResponse, error) {
	authClient := services.AuthServiceClient{BaseURL: "http://localhost:8081"}
	authResp, err := authClient.Login(email, password)
	if err != nil {
		return nil, err
	}
	userResp, err := authClient.GetCurrentUser(authResp.Token)
	if err != nil {
		return nil, err
	}
	user := &User{
		ID:    userResp.ID,
		Email: userResp.Email,
		Role:  userResp.Role,
	}
	return &AuthResponse{
		Token: authResp.Token,
		User:  user,
	}, nil
}

// CreateUser is the resolver for the createUser mutation.
func (r *mutationResolver) CreateUser(ctx context.Context, input CreateUserInput) (*User, error) {
	authHeader, _ := ctx.Value(authTokenKey).(string)
	authClient := services.AuthServiceClient{BaseURL: "http://localhost:8081"}

	// Convert our GraphQL input into the structure the REST API expects.
	payload := map[string]interface{}{
		"email":    input.Email,
		"password": input.Password,
		"role":     input.Role,
	}
	if input.StudentProfile != nil {
		payload["studentProfile"] = input.StudentProfile
	}
	if input.InstructorProfile != nil {
		payload["instructorProfile"] = input.InstructorProfile
	}

	userResp, err := authClient.CreateUser(authHeader, payload)
	if err != nil {
		return nil, err
	}

	return &User{
		ID:       userResp.ID,
		Email:    userResp.Email,
		Role:     userResp.Role,
		FullName: &userResp.FullName,
	}, nil
}

// CreateCourse is the resolver for the createCourse mutation.
func (r *mutationResolver) CreateCourse(ctx context.Context, input CreateCourseInput) (*Course, error) {
	authHeader, _ := ctx.Value(authTokenKey).(string)
	erpClient := services.ERPServiceClient{BaseURL: "http://localhost:8082"}

	courseResp, err := erpClient.CreateCourse(authHeader, input)
	if err != nil {
		return nil, err
	}

	return &Course{
		ID:         courseResp.ID,
		CourseCode: courseResp.CourseCode,
		Name:       courseResp.Name,
		Credits:    courseResp.Credits,
	}, nil
}

// RegisterForCourse is the resolver for the registerForCourse mutation.
func (r *mutationResolver) RegisterForCourse(ctx context.Context, courseID string, semester string) (*Registration, error) {
	authHeader, _ := ctx.Value(authTokenKey).(string)
	erpClient := services.ERPServiceClient{BaseURL: "http://localhost:8082"}
	regResp, err := erpClient.RegisterForCourse(authHeader, courseID, semester)
	if err != nil {
		return nil, err
	}
	return &Registration{
		CourseID: regResp.CourseID,
		Semester: regResp.Semester,
	}, nil
}

// Me is the resolver for the me query.
func (r *queryResolver) Me(ctx context.Context) (*User, error) {
	authHeader, _ := ctx.Value(authTokenKey).(string)
	rawToken := ""
	parts := strings.Split(authHeader, " ")
	if len(parts) == 2 {
		rawToken = parts[1]
	}
	authClient := services.AuthServiceClient{BaseURL: "http://localhost:8081"}
	userResp, err := authClient.GetCurrentUser(rawToken)
	if err != nil {
		return nil, err
	}
	return &User{
		ID:    userResp.ID,
		Email: userResp.Email,
		Role:  userResp.Role,
	}, nil
}

// Courses is the resolver for the courses query.
func (r *queryResolver) Courses(ctx context.Context) ([]*Course, error) {
	authHeader, _ := ctx.Value(authTokenKey).(string)
	authClient := services.AuthServiceClient{BaseURL: "http://localhost:8081"}
	erpClient := services.ERPServiceClient{BaseURL: "http://localhost:8082"}
	coursesResp, err := erpClient.ListCourses(authHeader)
	if err != nil {
		return nil, err
	}
	var gqlCourses []*Course
	for _, c := range coursesResp {
		instructor, err := authClient.GetUserByID(authHeader, c.InstructorID)
		var gqlInstructor *User
		if err == nil {
			gqlInstructor = &User{
				ID:       instructor.ID,
				Email:    instructor.Email,
				Role:     instructor.Role,
				FullName: &instructor.FullName,
			}
		}
		desc := c.Description
		gqlCourses = append(gqlCourses, &Course{
			ID:          c.ID,
			CourseCode:  c.CourseCode,
			Name:        c.Name,
			Description: &desc,
			Credits:     c.Credits,
			Instructor:  gqlInstructor,
		})
	}
	return gqlCourses, nil
}

// MyRegistrations is the resolver for the myRegistrations query.
func (r *queryResolver) MyRegistrations(ctx context.Context) ([]*Registration, error) {
	authHeader, _ := ctx.Value(authTokenKey).(string)
	erpClient := services.ERPServiceClient{BaseURL: "http://localhost:8082"}

	regResp, err := erpClient.ListMyRegistrations(authHeader)
	if err != nil {
		return nil, err
	}

	// Convert the service response into the GraphQL model.
	var gqlRegistrations []*Registration
	for _, r := range regResp {
		gqlRegistrations = append(gqlRegistrations, &Registration{
			CourseID: r.CourseID,
			Semester: r.Semester,
			// The 'course' field will be resolved by a separate field resolver if needed.
		})
	}

	return gqlRegistrations, nil
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
